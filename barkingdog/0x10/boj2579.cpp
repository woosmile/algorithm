#include <iostream>

using namespace std;

int s[305];
int n;
int d[305][3];

int main(void)
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    
    cin >> n;
    for(int i = 1; i <= n; i++)
        cin >> s[i];
    
    if(n == 1)
    {
        cout << s[1];  // 계단이 하나밖에 없으므로 첫번째 계단 출력
        return 0;
    }
    
    d[1][1] = s[1];  // 계단을 연속으로 1개 밟고 1번째 계단을 밟았을 때의 값 (= 첫번째 계단을 밟았음)
    d[1][2] = 0;  // 계단을 연속으로 2개 밟고 1번째 계단을 밟앗을 때의 값 (= 이런 경우는 존재하지 않으므로 0)
    d[2][1] = s[2];  // 계단을 연속으로 1개 밟고 2번째 계단을 밟았을 때의 값 (= 두번째 계단을 밟았음)
    d[2][2] = s[1] + s[2];  // 계단을 연속으로 2번 밟고 2번째 계단을 밟았을 때의 값 (= 첫번째 계단을 밟고 두번째 계단을 밟았음)
    
    for(int i = 3; i <= n; i++)
    {
        d[i][1] = max(d[i-2][1], d[i-2][2]) + s[i];  // 이번 계단이 첫번째라면 i - 2 번째 계단을 밟았음을 의미함 그럼, i-2번 계단을 첫번째로 밟았을 때와 두번째로 밟았을 때 2가지 경우 중 가장 큰 수 + 이번 계단의 값을 넣음
        d[i][2] = d[i-1][1] + s[i];  // 이번 계단이 두번째라면 이전 계단을 밟았음을 의미함 이전 계단을 처음 밟았을 때 + 이번 계단의 값을 넣음 (i-2는 문제 조건상 계단을 연속해서 3번 밟을 수 없으므로 고려하지 않음)
    }
    
    cout << max(d[n][1], d[n][2]);  // 1개 밟았을 때, 연속으로 2개 밟았을 때 2가지 경우 중 가장 큰 수 출력

    return 0;
}